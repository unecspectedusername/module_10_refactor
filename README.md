## Модуль 20 "Стандарты написания кода и общие подходы"

Практическое задание курса "Профессия Fullstack веб-разработчик на JavaScript и PHP"

### Практическое задание модуля

В рамках задания необходимо было выполнить рефакторинг кода для того, чтобы он соответствовал принципам DRY, KISS, YAGNI и SOLID.

Для рефакторинга я выбрал код из практического задания модуля 10. Оригинальный код можно посмотреть [здесь](https://github.com/unecspectedusername/php_fork/tree/master/bjs/10_function_object)

В рамках этого проекта я сосредоточился на соответствии принципам SOLID. Примеры применения принципов DRY, KISS и YAGNI я привел в [этом проекте](https://github.com/unecspectedusername/module_18_refactor)

### SOLID

#### 1. Single Responsibility Principle

>Каждый класс должен обладать одной зоной ответственности.

В оригинальном коде проекта все методы и данные были собраны в один объект personGenerator. Я разделил его на отдельные классы. В соответствии с Single Responsibility Principle каждый класс имеет только одну зону ответственности:

* Класс Person и наследуемые от него Employed, Man и Woman отвечают за создание и управление данными о конкретном человеке.
* DataParser - отвечает за парсинг JSON.
* Random - генерация случайных значений.
* Birthday - генерация даты рождения.
* PersonalData - генерация случайных личных данных (ФИО, аватар).

#### 2. Open-Closed Principle.

>Классы должны быть открыты для расширения, но закрыты для модификации.

От класса Person наследуется класс Employed, а от него, в свою очередь, классы Man и Woman. Я старался реализовать наследование таким образом, чтобы в случае добавления новых сущностей не нужно было менять код родительского класса.

Поэтому, если мы добавим новые сущности, например, Boy или Girl, мы можем наследовать их от Person и прописать им собственные геттеры для profession и gender не изменяя родительский класс.

#### 3. Liskov Substitution Principle.

>Функции, которые имеют базовый тип, должны иметь способность с ним взаимодействовать, а также и с его подтипами.


На примере тех же классов Man и Woman - они корректно реализуют поведение базового типа Employed.

#### 4. Interface Segregation Principle.

>Классы, которые наследуются от базового класса, не должны от них зависеть, если они не используют методы базового класса.

Для реализации этого принципа я создал класс Employed, чтобы в случае добавления новых типов, например Boy и Girl, их можно было наследовать от Person и они не зависели от геттера profession() т.к. они могут не иметь профессии.

#### 5. Dependency Inversion Principle.

>Верхний уровень модулей не должен зависеть от абстракций нижнего уровня.

Для реализации этого принципа я создал отдельные классы Random, PersonalData, DataParser и Birthday и передаю их экземпляры в конструктор класса Person.
